<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Strategy Lab Progress Tracker</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      :root {
        font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
        color: #1f2933;
        background-color: #f5f6fa;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
      }
      a {
        color: inherit;
      }
      main.page {
        max-width: 1120px;
        margin: 0 auto;
        padding: 2rem 1.5rem 4rem;
      }
      .page__header {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        margin-bottom: 2rem;
      }
      .page__header h1 {
        margin: 0;
        font-size: 2rem;
      }
      .status-banner {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
        background: #ffffff;
        border: 1px solid #e1e7ef;
        border-radius: 14px;
        padding: 1rem 1.25rem;
        box-shadow: 0 6px 18px rgba(15, 23, 42, 0.08);
      }
      .status-banner__metrics {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        font-size: 0.95rem;
      }
      .status-banner__metrics span {
        display: inline-flex;
        flex-direction: column;
        gap: 0.2rem;
      }
      .status-banner__metrics strong {
        font-size: 1.2rem;
      }
      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 0.6rem;
        margin-bottom: 1.5rem;
        font-size: 0.85rem;
        color: #52606d;
      }
      .legend__item {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        background: #ffffff;
        padding: 0.35rem 0.6rem;
        border-radius: 999px;
        border: 1px solid #e1e7ef;
      }
      .feature-card {
        background: #ffffff;
        border: 1px solid #e1e7ef;
        border-radius: 16px;
        padding: 1.25rem 1.5rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 8px 20px rgba(15, 23, 42, 0.08);
      }
      .feature-card__header {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
        margin-bottom: 1rem;
      }
      .feature-card__info {
        display: flex;
        gap: 0.75rem;
        align-items: flex-start;
      }
      .feature-card__checkbox,
      .method__checkbox,
      .test__checkbox {
        width: 1.1rem;
        height: 1.1rem;
        margin-top: 0.25rem;
        accent-color: #2563eb;
      }
      .feature-card__label,
      .method__label,
      .test__label {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
        cursor: pointer;
      }
      .feature-card__title {
        font-weight: 600;
        font-size: 1.15rem;
      }
      .feature-card__dates {
        font-size: 0.85rem;
        color: #52606d;
      }
      .feature-card__body {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }
      .feature-card--collapsed .feature-card__body {
        display: none;
      }
      .feature-card__header--collapsible {
        cursor: pointer;
      }
      .feature-card__header--collapsible input,
      .feature-card__header--collapsible label,
      .feature-card__header--collapsible button {
        cursor: pointer;
      }
      .feature-card__toggle {
        border: 1px solid #d1d9e6;
        background: #f1f5f9;
        color: #1f2933;
        padding: 0.3rem 0.75rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        cursor: pointer;
        transition: background-color 0.2s ease, border-color 0.2s ease;
      }
      .feature-card__toggle:hover {
        background: #e2e8f0;
        border-color: #c4cfde;
      }
      .feature-card__empty {
        margin: 0;
        padding: 1rem;
        border: 1px dashed #d7dce5;
        border-radius: 12px;
        background: #f8fafc;
        color: #64748b;
        font-style: italic;
      }
      .method-list,
      .test-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .method {
        border: 1px solid #edf0f7;
        border-radius: 12px;
        padding: 0.9rem 1rem;
        background: #fbfdff;
      }
      .method__header {
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        align-items: flex-start;
      }
      .method__info {
        display: flex;
        gap: 0.75rem;
      }
      .method__title {
        font-weight: 600;
      }
      .method__dates,
      .test__dates {
        font-size: 0.8rem;
        color: #64748b;
      }
      .test {
        border-top: 1px solid #e8edf5;
        padding-top: 0.75rem;
        margin-top: 0.75rem;
      }
      .test:first-child {
        border-top: none;
        padding-top: 0;
        margin-top: 0;
      }
      .test__row {
        display: flex;
        justify-content: space-between;
        gap: 0.75rem;
        align-items: flex-start;
      }
      .test__info {
        display: flex;
        flex-direction: column;
        gap: 0.25rem;
      }
      .test__title {
        font-size: 0.9rem;
        font-weight: 500;
      }
      .status-pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.3rem 0.75rem;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.03em;
        min-width: 7.5rem;
        text-align: center;
      }
      .status-pill--green {
        background: #dcfce7;
        color: #166534;
      }
      .status-pill--blue {
        background: #dbeafe;
        color: #1d4ed8;
      }
      .status-pill--grey {
        background: #e2e8f0;
        color: #334155;
      }
      .status-pill--orange {
        background: #fef3c7;
        color: #b45309;
      }
      .status-pill--red {
        background: #fee2e2;
        color: #b91c1c;
      }
      [data-status="overdue"] {
        border-color: #fecaca;
      }
      [data-status="due-soon"] {
        border-color: #fde68a;
      }
      [data-status="ahead"] {
        border-color: #bfdbfe;
      }
      [data-status="complete"] {
        border-color: #bbf7d0;
        background: #f0fdf4;
      }
      @media (max-width: 720px) {
        .status-banner {
          flex-direction: column;
          align-items: flex-start;
        }
        .method__header,
        .test__row,
        .feature-card__header {
          flex-direction: column;
          align-items: flex-start;
        }
        .status-pill {
          min-width: unset;
        }
      }
    </style>
  </head>
  <body>
    <main class="page">
      <header class="page__header">
        <h1>Strategy Lab Progress Tracker</h1>
        <div class="status-banner">
          <span id="project-status" class="status-pill status-pill--grey">Pending</span>
          <div class="status-banner__metrics">
            <span>Features<br><strong id="feature-progress">0 / 0</strong></span>
            <span>Methods<br><strong id="method-progress">0 / 0</strong></span>
            <span>Tests<br><strong id="test-progress">0 / 0</strong></span>
            <span>Overdue<br><strong id="overdue-count">0</strong></span>
            <span>Due Soon<br><strong id="due-soon-count">0</strong></span>
          </div>
        </div>
        <div class="legend">
          <span class="legend__item"><span class="status-pill status-pill--green">Complete</span>Complete</span>
          <span class="legend__item"><span class="status-pill status-pill--blue">Ahead</span>Ahead of Schedule</span>
          <span class="legend__item"><span class="status-pill status-pill--grey">On Track</span>On Track</span>
          <span class="legend__item"><span class="status-pill status-pill--orange">Due Soon</span>Due within 7 days</span>
          <span class="legend__item"><span class="status-pill status-pill--red">Behind</span>Overdue</span>
        </div>
      </header>
      <section id="feature-container"></section>
    </main>
    <script src="progress-data.js"></script>
    <script>
      (function () {
        const data = window.progressData;
        if (!data || !Array.isArray(data.features)) {
          console.warn("Progress data unavailable.");
          return;
        }

        const container = document.getElementById("feature-container");
        const featureProgressEl = document.getElementById("feature-progress");
        const methodProgressEl = document.getElementById("method-progress");
        const testProgressEl = document.getElementById("test-progress");
        const overdueCountEl = document.getElementById("overdue-count");
        const dueSoonCountEl = document.getElementById("due-soon-count");
        const projectStatusEl = document.getElementById("project-status");

        const storageKey = "strategy-lab-progress-v1";
        const storage = (() => {
          try {
            const store = window.localStorage;
            const testKey = "__progress-test__";
            store.setItem(testKey, "ok");
            store.removeItem(testKey);
            return store;
          } catch (err) {
            return null;
          }
        })();

        let savedChecks = {};
        if (storage) {
          try {
            const parsed = JSON.parse(storage.getItem(storageKey) || "{}");
            if (parsed && typeof parsed === "object") {
              savedChecks = parsed;
            }
          } catch (err) {
            savedChecks = {};
          }
        }

        const items = new Map();
        const MS_PER_DAY = 24 * 60 * 60 * 1000;
        const today = (() => {
          const now = new Date();
          return new Date(now.getFullYear(), now.getMonth(), now.getDate());
        })();
        const dateFormatter = new Intl.DateTimeFormat("en-US", {
          month: "short",
          day: "2-digit",
          year: "numeric",
        });

        const statusLabels = {
          complete: "Complete",
          ahead: "Ahead of Schedule",
          "on-track": "On Track",
          "due-soon": "Due Soon",
          overdue: "Behind Schedule",
          pending: "Pending",
        };
        const statusClasses = {
          complete: "status-pill status-pill--green",
          ahead: "status-pill status-pill--blue",
          "on-track": "status-pill status-pill--grey",
          "due-soon": "status-pill status-pill--orange",
          overdue: "status-pill status-pill--red",
          pending: "status-pill status-pill--grey",
        };

        function parseDate(value) {
          if (!value) {
            return null;
          }
          const parts = value.split("-");
          if (parts.length !== 3) {
            return null;
          }
          const year = Number(parts[0]);
          const month = Number(parts[1]) - 1;
          const day = Number(parts[2]);
          if (
            Number.isNaN(year) ||
            Number.isNaN(month) ||
            Number.isNaN(day)
          ) {
            return null;
          }
          return new Date(year, month, day, 23, 59, 59, 999);
        }

        function formatRange(start, due) {
          const startDate = parseDate(start);
          const dueDate = parseDate(due);
          if (!startDate && !dueDate) {
            return "Schedule: TBD";
          }
          if (!startDate) {
            return `Due ${dateFormatter.format(dueDate)}`;
          }
          if (!dueDate) {
            return `Start ${dateFormatter.format(startDate)}`;
          }
          return `${dateFormatter.format(startDate)} - ${dateFormatter.format(dueDate)}`;
        }

        function formatSingle(start, due) {
          const startDate = parseDate(start);
          const dueDate = parseDate(due);
          if (startDate && dueDate) {
            return `Start ${dateFormatter.format(startDate)} -> Due ${dateFormatter.format(dueDate)}`;
          }
          if (dueDate) {
            return `Due ${dateFormatter.format(dueDate)}`;
          }
          if (startDate) {
            return `Start ${dateFormatter.format(startDate)}`;
          }
          return "Schedule: TBD";
        }

        function createStatusPill() {
          const pill = document.createElement("span");
          pill.className = statusClasses.pending;
          pill.textContent = statusLabels.pending;
          return pill;
        }

        function createFeature(featureData) {
          const featureCard = document.createElement("section");
          featureCard.className = "feature-card";
          featureCard.dataset.id = featureData.id;

          const header = document.createElement("header");
          header.className = "feature-card__header";
          header.classList.add("feature-card__header--collapsible");

          const info = document.createElement("div");
          info.className = "feature-card__info";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = featureData.id;
          checkbox.className = "feature-card__checkbox";

          const label = document.createElement("label");
          label.className = "feature-card__label";
          label.htmlFor = featureData.id;

          const title = document.createElement("span");
          title.className = "feature-card__title";
          title.textContent = featureData.title;

          const dates = document.createElement("span");
          dates.className = "feature-card__dates";
          dates.textContent = formatRange(featureData.start, featureData.due);

          label.appendChild(title);
          label.appendChild(dates);
          info.appendChild(checkbox);
          info.appendChild(label);

          const statusPill = createStatusPill();
          const toggleButton = document.createElement("button");
          toggleButton.type = "button";
          toggleButton.className = "feature-card__toggle";
          toggleButton.textContent = "Collapse";
          toggleButton.setAttribute("aria-expanded", "true");

          header.appendChild(info);
          header.appendChild(toggleButton);
          header.appendChild(statusPill);
          featureCard.appendChild(header);

          const item = {
            id: featureData.id,
            type: "feature",
            element: featureCard,
            checkbox,
            statusPill,
            parentId: null,
            children: [],
            startDate: parseDate(featureData.start),
            dueDate: parseDate(featureData.due),
            status: "pending",
          };
          items.set(featureData.id, item);

          const body = document.createElement("div");
          body.className = "feature-card__body";

          if (featureData.methods.length === 0) {
            const emptyState = document.createElement("p");
            emptyState.className = "feature-card__empty";
            emptyState.textContent = "No methods tracked yet.";
            body.appendChild(emptyState);
          } else {
            const methodList = document.createElement("ul");
            methodList.className = "method-list";
            featureData.methods.forEach((methodData) => {
              const methodItem = createMethod(methodData, featureData.id);
              methodList.appendChild(methodItem.element);
            });
            body.appendChild(methodList);
          }

          featureCard.appendChild(body);

          const setCollapsedState = (collapsed) => {
            featureCard.classList.toggle("feature-card--collapsed", collapsed);
            toggleButton.setAttribute("aria-expanded", String(!collapsed));
            toggleButton.textContent = collapsed ? "Expand" : "Collapse";
          };
          setCollapsedState(false);

          checkbox.addEventListener("change", (event) => {
            handleToggle(event.target.id, event.target.checked);
          });

          toggleButton.addEventListener("click", (event) => {
            event.stopPropagation();
            setCollapsedState(
              !featureCard.classList.contains("feature-card--collapsed")
            );
          });

          header.addEventListener("click", (event) => {
            if (
              event.target === checkbox ||
              event.target.closest("label") ||
              event.target.closest("input") ||
              event.target.closest(".feature-card__toggle")
            ) {
              return;
            }
            setCollapsedState(
              !featureCard.classList.contains("feature-card--collapsed")
            );
          });

          container.appendChild(featureCard);
          return item;
        }

        function createMethod(methodData, featureId) {
          const methodEntry = document.createElement("li");
          methodEntry.className = "method";
          methodEntry.dataset.id = methodData.id;

          const header = document.createElement("div");
          header.className = "method__header";

          const info = document.createElement("div");
          info.className = "method__info";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = methodData.id;
          checkbox.className = "method__checkbox";

          const label = document.createElement("label");
          label.className = "method__label";
          label.htmlFor = methodData.id;

          const title = document.createElement("span");
          title.className = "method__title";
          title.textContent = methodData.title;

          const dates = document.createElement("span");
          dates.className = "method__dates";
          dates.textContent = formatSingle(methodData.start, methodData.due);

          label.appendChild(title);
          label.appendChild(dates);

          info.appendChild(checkbox);
          info.appendChild(label);

          const statusPill = createStatusPill();

          const item = {
            id: methodData.id,
            type: "method",
            element: methodEntry,
            checkbox,
            statusPill,
            parentId: featureId,
            children: [],
            startDate: parseDate(methodData.start),
            dueDate: parseDate(methodData.due),
            status: "pending",
          };
          items.set(methodData.id, item);
          items.get(featureId).children.push(methodData.id);

          header.appendChild(info);
          header.appendChild(statusPill);
          methodEntry.appendChild(header);

          const testList = document.createElement("ul");
          testList.className = "test-list";
          methodData.tests.forEach((testData) => {
            const testItem = createTest(testData, methodData.id);
            testList.appendChild(testItem.element);
          });
          methodEntry.appendChild(testList);

          checkbox.addEventListener("change", (event) => {
            handleToggle(event.target.id, event.target.checked);
          });

          return item;
        }

        function createTest(testData, methodId) {
          const testEntry = document.createElement("li");
          testEntry.className = "test";
          testEntry.dataset.id = testData.id;

          const row = document.createElement("div");
          row.className = "test__row";

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = testData.id;
          checkbox.className = "test__checkbox";

          const label = document.createElement("label");
          label.className = "test__label";
          label.htmlFor = testData.id;

          const title = document.createElement("span");
          title.className = "test__title";
          title.textContent = testData.title;

          const dates = document.createElement("span");
          dates.className = "test__dates";
          dates.textContent = formatSingle(testData.start, testData.due);

          label.appendChild(title);
          label.appendChild(dates);

          const statusPill = createStatusPill();

          row.appendChild(checkbox);
          row.appendChild(label);
          row.appendChild(statusPill);
          testEntry.appendChild(row);

          const item = {
            id: testData.id,
            type: "test",
            element: testEntry,
            checkbox,
            statusPill,
            parentId: methodId,
            children: [],
            startDate: parseDate(testData.start),
            dueDate: parseDate(testData.due),
            status: "pending",
          };
          items.set(testData.id, item);
          items.get(methodId).children.push(testData.id);

          checkbox.addEventListener("change", (event) => {
            handleToggle(event.target.id, event.target.checked);
          });

          return item;
        }

        function computeLeafStatus(item) {
          if (item.checkbox.checked) {
            return "complete";
          }
          if (!item.dueDate) {
            return "on-track";
          }
          const diff = Math.ceil((item.dueDate - today) / MS_PER_DAY);
          if (diff < 0) {
            return "overdue";
          }
          if (diff <= 7) {
            return "due-soon";
          }
          if (diff <= 14) {
            return "on-track";
          }
          return "ahead";
        }

        function computeStatus(item) {
          if (item.checkbox.checked) {
            return "complete";
          }
          if (item.children.length === 0) {
            return computeLeafStatus(item);
          }
          const childStatuses = item.children.map((childId) => {
            const child = items.get(childId);
            return child ? child.status : "pending";
          });
          if (childStatuses.every((status) => status === "complete")) {
            return "complete";
          }
          if (childStatuses.some((status) => status === "overdue")) {
            return "overdue";
          }
          if (childStatuses.some((status) => status === "due-soon")) {
            return "due-soon";
          }
          if (childStatuses.some((status) => status === "ahead")) {
            return "ahead";
          }
          if (childStatuses.some((status) => status === "on-track")) {
            return "on-track";
          }
          return "pending";
        }

        function refreshVisual(itemId) {
          const item = items.get(itemId);
          if (!item) {
            return;
          }
          const status = computeStatus(item);
          item.status = status;
          item.element.dataset.status = status;
          if (item.statusPill) {
            item.statusPill.textContent = statusLabels[status];
            item.statusPill.className = statusClasses[status];
          }
        }

        function updateAncestors(itemId) {
          const item = items.get(itemId);
          if (!item || !item.parentId) {
            return;
          }
          const parent = items.get(item.parentId);
          if (!parent) {
            return;
          }
          const children = parent.children.map((childId) =>
            items.get(childId)
          );
          const someChecked = children.some(
            (child) => child && child.checkbox.checked
          );
          const someIndeterminate = children.some(
            (child) => child && child.checkbox.indeterminate
          );
          const allChecked = children.every(
            (child) => child && child.checkbox.checked
          );
          if (!parent.checkbox.checked) {
            parent.checkbox.indeterminate =
              (someChecked && !allChecked) || someIndeterminate;
          } else {
            parent.checkbox.indeterminate = false;
          }
          refreshVisual(parent.id);
          updateAncestors(parent.id);
        }

        function toggleItem(itemId, checked, options) {
          const item = items.get(itemId);
          if (!item) {
            return;
          }
          const cascadeDown =
            options && Object.prototype.hasOwnProperty.call(options, "cascadeDown")
              ? options.cascadeDown
              : true;
          const cascadeUp =
            options && Object.prototype.hasOwnProperty.call(options, "cascadeUp")
              ? options.cascadeUp
              : true;

          item.checkbox.checked = checked;
          item.checkbox.indeterminate = false;
          if (checked) {
            savedChecks[itemId] = true;
          } else {
            delete savedChecks[itemId];
          }

          if (cascadeDown) {
            item.children.forEach((childId) => {
              toggleItem(childId, checked, { cascadeDown: true, cascadeUp: false });
            });
          }

          refreshVisual(itemId);

          if (cascadeUp) {
            updateAncestors(itemId);
          }
        }

        function handleToggle(itemId, checked) {
          const item = items.get(itemId);
          if (!item) {
            return;
          }
          const cascadeDown = item.type === "feature";
          toggleItem(itemId, checked, {
            cascadeDown,
            cascadeUp: true,
          });
          updateProjectSummary();
          persistState();
        }

        function persistState() {
          if (!storage) {
            return;
          }
          try {
            storage.setItem(storageKey, JSON.stringify(savedChecks));
          } catch (err) {
            // Ignore storage errors (e.g., quota exceeded).
          }
        }

        function updateProjectSummary() {
          const counts = {
            feature: { total: 0, complete: 0 },
            method: { total: 0, complete: 0 },
            test: { total: 0, complete: 0 },
            overdue: 0,
            dueSoon: 0,
          };
          let earliestPendingDue = null;

          items.forEach((item) => {
            const status = item.status;
            if (item.type === "feature") {
              counts.feature.total += 1;
              if (item.checkbox.checked) {
                counts.feature.complete += 1;
              }
            } else if (item.type === "method") {
              counts.method.total += 1;
              if (item.checkbox.checked) {
                counts.method.complete += 1;
              }
            } else if (item.type === "test") {
              counts.test.total += 1;
              if (item.checkbox.checked) {
                counts.test.complete += 1;
              } else {
                if (status === "overdue") {
                  counts.overdue += 1;
                } else if (status === "due-soon") {
                  counts.dueSoon += 1;
                }
                if (item.dueDate) {
                  if (
                    earliestPendingDue === null ||
                    item.dueDate < earliestPendingDue
                  ) {
                    earliestPendingDue = item.dueDate;
                  }
                }
              }
            }
          });

          featureProgressEl.textContent = `${counts.feature.complete} / ${counts.feature.total}`;
          methodProgressEl.textContent = `${counts.method.complete} / ${counts.method.total}`;
          testProgressEl.textContent = `${counts.test.complete} / ${counts.test.total}`;
          overdueCountEl.textContent = String(counts.overdue);
          dueSoonCountEl.textContent = String(counts.dueSoon);

          let statusKey = "on-track";
          if (counts.test.total > 0 && counts.test.complete === counts.test.total) {
            statusKey = "complete";
          } else if (counts.overdue > 0) {
            statusKey = "overdue";
          } else if (earliestPendingDue) {
            const diff = Math.ceil((earliestPendingDue - today) / MS_PER_DAY);
            if (diff < 0) {
              statusKey = "overdue";
            } else if (diff <= 7) {
              statusKey = "due-soon";
            } else if (diff <= 14) {
              statusKey = "on-track";
            } else {
              statusKey = "ahead";
            }
          } else if (counts.test.total === 0) {
            statusKey = "pending";
          }

          projectStatusEl.textContent = statusLabels[statusKey];
          projectStatusEl.className = statusClasses[statusKey];
        }

        // Build the DOM tree.
        data.features.forEach((featureData) => {
          createFeature(featureData);
        });

        const typeRank = {
          test: 0,
          method: 1,
          feature: 2,
        };

        items.forEach((item) => {
          if (savedChecks[item.id]) {
            item.checkbox.checked = true;
          }
        });

        Array.from(items.values())
          .sort((a, b) => typeRank[b.type] - typeRank[a.type])
          .forEach((item) => {
            if (item.children.length === 0) {
              return;
            }
            const children = item.children
              .map((childId) => items.get(childId))
              .filter(Boolean);
            const allChecked = children.every((child) => child.checkbox.checked);
            const someChecked = children.some(
              (child) => child.checkbox.checked || child.checkbox.indeterminate
            );
            item.checkbox.checked = allChecked;
            item.checkbox.indeterminate = !allChecked && someChecked;
            if (item.checkbox.checked) {
              savedChecks[item.id] = true;
            } else {
              delete savedChecks[item.id];
            }
          });

        Array.from(items.values())
          .sort((a, b) => typeRank[a.type] - typeRank[b.type])
          .forEach((item) => {
            refreshVisual(item.id);
          });

        updateProjectSummary();
        persistState();
      })();
    </script>
  </body>
</html>
